###Two pool soil model with non-linear
###explicit microbial feedback
###drawn from Wang et al. (2014) yearly
###version of German et al. (2012) model
rm(list=ls())
library(deSolve)
library(ggplot2)
#model function
Soil_Mic <- function(t, y, parms){
#set initial state values
Cmic  <-  y[1]
Csoil <-  y[2]
#set parameter values
Input_litter   <-  parms[1] #carbon input (g C m^-2 year^-1)
Temp_soil      <-  parms[2] #mean soil temp top 1m (Celcius)
U              <-  parms[3] #turnover rate of microbial biomass (year^-1)
Eps            <-  parms[4] #microbial growth efficency
#calculated values
#maximum rate of soil C assimilation per unit microbial biomass per year (g C m^-2)
V   <-  (8*(10^-6)*exp(5.47+(0.063*Temp_soil))*(24*365))*8
#half-saturation constant for soil C assimilation by microbial biomass (g C m^-2)
K   <-  (10*exp(3.19+(0.007*Temp_soil))*1000)*0.2
#model equations
dCmic   <-  Eps*((Cmic*V*Csoil)/(Csoil+K))-(U*Cmic)
dCsoil  <-  Input_litter+(U*Cmic)-((Cmic*V*Csoil)/(Csoil+K))
return(list(c(dCmic, dCsoil)))
}
#model setup
times <- seq(0,50,1) #annual time step
Pars  <- c(Input_litter=350, Temp_soil=15, U=4.38, Eps=0.5)
####Suggested ranges for variation
####Input_litter 50-500, larger values stabilize more quickly
####Temp_soil -5 to 35. Higher temps stabilize more quickly
####U poorly understood rate. This value set based on other studies.
####Eps 0.2 - 0.6. Lower values (less efficient microbial growth) cause longer time to stabilization
yini  <- c(Cmic=100, Csoil=1000)
#Run model
out<-lsoda(func=Soil_Mic, y=yini, parms=Pars, times=times)
plot(out,ylab=expression(paste("Carbon (g C ", m^-2, ")")), xlab="year")
install.packages("deSolve")
###Two pool soil model with non-linear
###explicit microbial feedback
###drawn from Wang et al. (2014) yearly
###version of German et al. (2012) model
rm(list=ls())
library(deSolve)
library(ggplot2)
#model function
Soil_Mic <- function(t, y, parms){
#set initial state values
Cmic  <-  y[1]
Csoil <-  y[2]
#set parameter values
Input_litter   <-  parms[1] #carbon input (g C m^-2 year^-1)
Temp_soil      <-  parms[2] #mean soil temp top 1m (Celcius)
U              <-  parms[3] #turnover rate of microbial biomass (year^-1)
Eps            <-  parms[4] #microbial growth efficency
#calculated values
#maximum rate of soil C assimilation per unit microbial biomass per year (g C m^-2)
V   <-  (8*(10^-6)*exp(5.47+(0.063*Temp_soil))*(24*365))*8
#half-saturation constant for soil C assimilation by microbial biomass (g C m^-2)
K   <-  (10*exp(3.19+(0.007*Temp_soil))*1000)*0.2
#model equations
dCmic   <-  Eps*((Cmic*V*Csoil)/(Csoil+K))-(U*Cmic)
dCsoil  <-  Input_litter+(U*Cmic)-((Cmic*V*Csoil)/(Csoil+K))
return(list(c(dCmic, dCsoil)))
}
#model setup
times <- seq(0,50,1) #annual time step
Pars  <- c(Input_litter=350, Temp_soil=15, U=4.38, Eps=0.5)
####Suggested ranges for variation
####Input_litter 50-500, larger values stabilize more quickly
####Temp_soil -5 to 35. Higher temps stabilize more quickly
####U poorly understood rate. This value set based on other studies.
####Eps 0.2 - 0.6. Lower values (less efficient microbial growth) cause longer time to stabilization
yini  <- c(Cmic=100, Csoil=1000)
#Run model
out<-lsoda(func=Soil_Mic, y=yini, parms=Pars, times=times)
plot(out,ylab=expression(paste("Carbon (g C ", m^-2, ")")), xlab="year")
#R Script paired with Introduction to R
#series for the Trace Gas Biogeochem Lab
#Last updated 10/28/2016
#created by Nell Campbell
#clear workspace
rm(list=ls())
#Part 1- Introduction to data objects
#####SCALAR
#scalar is a single piece of information
ex_num_scalar<- 3
ex_char_scalar<- "hello"
#check that scalars objects contain the information you expect
ex_num_scalar
ex_char_scalar
#####VECTOR
#vector is a list of information (e.g. single row or single column)
# 'c' concatenates information separated by commas in parentheses
#use "" for character strings (e.g. words, IDs)
ex_num_vector<- c(3,5,7,19,22)
ex_char_vector<- c("hello","there","world")
#check that vector objects contain the information you expect
ex_num_vector
ex_char_vector
#information in vector can be referenced by location in list
ex_num_vector[3] #should print value 7
ex_char_vector[c(1,3)] #calls 1st and 3rd place in vector, printing "hello" "world"
#####MATRIX
#references to matrix cells is always ordered: rows, columns
#matrices must have all of the same type of data, e.g. 'numeric', or 'character'
#step one, create a matrix of 2 rows and 12 columns, filled with the value '0'
ex_matrix<- matrix(0, nrow=2, ncol=12)
#check that matrix was created properly
ex_matrix
#step two, fill the first row with a sequence of values from 1 to the value of the
#total number of columns (in this case, ncol(ex_matrix)=12)
#let's check that we know how to make a sequence like this using the 'seq' function:
#seq(from=start of sequence, to=end of sequence, by=units of sequence) 
seq(from=1,to=ncol(ex_matrix), by=1)
#now, fill in the first row of the matrix with these values
ex_matrix[1,]<- seq(from=1,to=ncol(ex_matrix), by=1)
#what does the matrix look like now?
ex_matrix
#now let's fill the second row with randomly selected values
#from a normal distribution, one for each column
#we'll use the rnorm function to randomly select numbers, which looks like:
#rnorm(x=number of points, mean=mean of points, sd=standard deviation of points) 
#first, check that the function is set up properly
#remember, ncol(ex_matrix)<-12 in this example
rnorm(n=ncol(ex_matrix), mean=3, sd=.5)
#now, run that same code to fill in second row of matrix
ex_matrix[2,]<-rnorm(n=ncol(ex_matrix), mean=3, sd=.5)
#what does the matrix look like now?
ex_matrix
#let's plot the results
#at its most basic, the plot function needs: plot(x=x values, y=y values)
#plot function is very flexible. Here I want the type to be line, and the 
#line to be red
plot(x=ex_matrix[1,], y=ex_matrix[2,], typ="l", col="red")
rm(list=ls())
ex_num_scalar<- 3
ex_char_scalar<- "hello"
ex_num_scalar
ex_char_scalar
#clear workspace
rm(list=ls())
#Part 1- Introduction to data objects
#####SCALAR
#scalar is a single piece of information
ex_num_scalar<- 3
ex_char_scalar<- "hello"
#check that scalars objects contain the information you expect
ex_num_scalar
ex_char_scalar
#####VECTOR
#vector is a list of information (e.g. single row or single column)
# 'c' concatenates information separated by commas in parentheses
#use "" for character strings (e.g. words, IDs)
ex_num_vector<- c(3,5,7,19,22)
ex_char_vector<- c("hello","there","world")
#check that vector objects contain the information you expect
ex_num_vector
ex_char_vector
#information in vector can be referenced by location in list
ex_num_vector[3] #should print value 7
ex_char_vector[c(1,3)] #calls 1st and 3rd place in vector, printing "hello" "world"
#####MATRIX
#references to matrix cells is always ordered: rows, columns
#matrices must have all of the same type of data, e.g. 'numeric', or 'character'
#step one, create a matrix of 2 rows and 12 columns, filled with the value '0'
ex_matrix<- matrix(0, nrow=2, ncol=12)
#check that matrix was created properly
ex_matrix
ex_matrix
#step two, fill the first row with a sequence of values from 1 to the value of the
#total number of columns (in this case, ncol(ex_matrix)=12)
#let's check that we know how to make a sequence like this using the 'seq' function:
#seq(from=start of sequence, to=end of sequence, by=units of sequence) 
seq(from=1,to=ncol(ex_matrix), by=1)
#now, fill in the first row of the matrix with these values
ex_matrix[1,]<- seq(from=1,to=ncol(ex_matrix), by=1)
#what does the matrix look like now?
ex_matrix
#now let's fill the second row with randomly selected values
#from a normal distribution, one for each column
#we'll use the rnorm function to randomly select numbers, which looks like:
#rnorm(x=number of points, mean=mean of points, sd=standard deviation of points) 
#first, check that the function is set up properly
#remember, ncol(ex_matrix)<-12 in this example
rnorm(n=ncol(ex_matrix), mean=3, sd=.5)
#now, run that same code to fill in second row of matrix
ex_matrix[2,]<-rnorm(n=ncol(ex_matrix), mean=3, sd=.5)
#what does the matrix look like now?
ex_matrix
#let's plot the results
#at its most basic, the plot function needs: plot(x=x values, y=y values)
#plot function is very flexible. Here I want the type to be line, and the 
#line to be red
plot(x=ex_matrix[1,], y=ex_matrix[2,], typ="l", col="red")
q()
#R Script paired with Introduction to R
#series for the Trace Gas Biogeochem Lab
#Last updated 10/28/2016
#created by Nell Campbell
#clear workspace
rm(list=ls())
#Set working directory
setwd("C:/Users/Tom/Documents/GitHub/RScriptsLab")
#Part 1- Introduction to data objects
#####SCALAR
#scalar is a single piece of information
ex_num_scalar<- 3
ex_char_scalar<- "hello"
#check that scalars objects contain the information you expect
ex_num_scalar
ex_char_scalar
#####VECTOR
#vector is a list of information (e.g. single row or single column)
# 'c' concatenates information separated by commas in parentheses
#use "" for character strings (e.g. words, IDs)
ex_num_vector<- c(3,5,7,19,22)
ex_char_vector<- c("hello","there","world")
#check that vector objects contain the information you expect
ex_num_vector
ex_char_vector
#information in vector can be referenced by location in list
ex_num_vector[3] #should print value 7
ex_char_vector[c(1,3)] #calls 1st and 3rd place in vector, printing "hello" "world"
#####MATRIX
#references to matrix cells is always ordered: rows, columns
#matrices must have all of the same type of data, e.g. 'numeric', or 'character'
#step one, create a matrix of 2 rows and 12 columns, filled with the value '0'
ex_matrix<- matrix(0, nrow=2, ncol=12)
#check that matrix was created properly
ex_matrix
#step two, fill the first row with a sequence of values from 1 to the value of the
#total number of columns (in this case, ncol(ex_matrix)=12)
#let's check that we know how to make a sequence like this using the 'seq' function:
#seq(from=start of sequence, to=end of sequence, by=units of sequence) 
seq(from=1,to=ncol(ex_matrix), by=1)
#now, fill in the first row of the matrix with these values
ex_matrix[1,]<- seq(from=1,to=ncol(ex_matrix), by=1)
#what does the matrix look like now?
ex_matrix
#now let's fill the second row with randomly selected values
#from a normal distribution, one for each column
#we'll use the rnorm function to randomly select numbers, which looks like:
#rnorm(x=number of points, mean=mean of points, sd=standard deviation of points) 
#first, check that the function is set up properly
#remember, ncol(ex_matrix)<-12 in this example
rnorm(n=ncol(ex_matrix), mean=3, sd=.5)
#now, run that same code to fill in second row of matrix
ex_matrix[2,]<-rnorm(n=ncol(ex_matrix), mean=3, sd=.5)
#what does the matrix look like now?
ex_matrix
#let's plot the results
#at its most basic, the plot function needs: plot(x=x values, y=y values)
#plot function is very flexible. Here I want the type to be line, and the 
#line to be red
plot(x=ex_matrix[1,], y=ex_matrix[2,], typ="l", col="red")
q()
